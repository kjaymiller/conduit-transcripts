---
description: '<p>Vector Podcast website: <a target="_blank" rel="noopener noreferrer
  nofollow" href="https://vectorpodcast.com">https://vectorpodcast.com</a></p><p></p><p>Get
  your copy of John''s new book "Prompt Engineering for LLMs: The Art and Science
  of Building Large Language Modelâ€“Based Applications": <a target="_blank" rel="noopener
  noreferrer nofollow" href="https://amzn.to/4fMj2Ef">https://amzn.to/4fMj2Ef</a></p><p></p><p><em>John
  Berryman is the founder and principal consultant of </em><a target="_blank" rel="noopener
  noreferrer nofollow" href="https://arcturus-labs.com/"><em>Arcturus Labs</em></a><em>,
  where he specializes in AI application development (Agency and RAG). As an early
  engineer on GitHub Copilot, John contributed to the development of its completions
  and chat functionalities, working at the forefront of AI-assisted coding tools.
  John is coauthor of </em><a target="_blank" rel="noopener noreferrer nofollow" href="https://amzn.to/4fMj2Ef"><em>"Prompt
  Engineering for LLMs" (O''Reilly)</em></a><em>.Before his work on Copilot, John''s
  focus was search technology. His diverse experience includes helping to develop
  next-generation search system for the US Patent Office, building search and recommendations
  for Eventbrite, and contributing to GitHub''s code search infrastructure. John is
  also coauthor of </em><a target="_blank" rel="noopener noreferrer nofollow" href="https://amzn.to/3TXmDHk"><em>"Relevant
  Search" (Manning)</em></a><em>, a book that distills his expertise in the field.John''s
  unique background, spanning both cutting-edge AI applications and foundational search
  technologies, positions him at the forefront of innovation in LLM applications and
  information retrieval.</em></p><p></p><p>00:00 Intro</p><p>02:19 John''s background
  and story in search and ML</p><p>06:03 Is RAG just a prompt engineering technique?</p><p>10:15
  John''s progression from a search engineer to ML researcher</p><p>13:40 LLM predictability
  vs more traditional programming</p><p>22:31 Code assist with GitHub Copilot</p><p>29:44
  Role of keyword search for code at GitHub</p><p>35:01 GenAI: existential risk or
  pure magic? AI Natives</p><p>39:40 What are Artifacts</p><p>46:59 Demo!</p><p>55:13
  Typed artifacts, tools, accordion artifacts</p><p>56:21 From Web 2.0 to Idea exchange</p><p>57:51
  Spam will transform into Slop</p><p>58:56 John''s new book and Acturus Labs intro</p><p></p><p>Show
  notes:</p><p>- John Berryman on X: <a target="_blank" rel="noopener noreferrer nofollow"
  href="https://x.com/JnBrymn">https://x.com/JnBrymn</a></p><p>- Acturus Labs: <a
  target="_blank" rel="noopener noreferrer nofollow" href="https://arcturus-labs.com/">https://arcturus-labs.com/</a></p><p>-
  John''s blog on Artifacts (see demo in the episode): <a target="_blank" rel="noopener
  noreferrer nofollow" href="https://arcturus-labs.com/blog/2024/11/11/cut-the-chit-chat-with-artifacts/">https://arcturus-labs.com/blog/2024/11/11/cut-the-chit-chat-with-artifacts/</a></p><p></p><p>Watch
  on <a target="_blank" rel="noopener noreferrer nofollow" href="https://youtu.be/60HAtHVBYj8">https://youtu.be/60HAtHVBYj8</a></p>'
image_url: https://media.rss.com/vector-podcast/ep_cover_20250209_090249_4151453caa902e94e1bbf399c57f535b.png
pub_date: Mon, 10 Feb 2025 03:21:48 GMT
title: Code search, Copilot, LLM prompting with empathy and Artifacts with John Berryman
url: https://rss.com/podcasts/vector-podcast/1888857
---

Hello everyone, Vector podcast is back. Season 3. We are wrapping up the season with some really, really juicy episodes. I'm sure you will love this one. I have the privilege of talking to John Barryman today. He is an ex senior machine learning researcher who worked on GitHub Copilot.
Currently, he runs his own consultancy actress labs. I'm sure he will talk more about that. Yeah, welcome, John. Good to be here. How's it going? Awesome. I actually just picked the book of yours and the book that you and Dr. Moll have written together.
I've interviewed Doug a couple of times already on the podcast. He has a lot to say. And I realized you've written this book together. It's my go-to source of wisdom on search. Do you still remember which chapters you covered? Oh my gosh. It's been a long time, I'm sure.
Yeah, if you told me the chapter title, I could probably say whether it is mere Doug. I did all the fun ones that did all hard ones. And we both did chapter one in our own times. I mean, we were all in chapter twice.
I want to read maybe everything, but in the search relevance problems, search under the hood, debugging, relevance problem, tame in tokens, basic multi-field search, how you build relevance function, feed relevance feedback. Yeah, relevance centered enterprise. That's interesting.
And then semantic and personalized search. Wow. Back in when was this published? I think we published that in 2016, I see. Yeah, 2016. Yeah, well, it's been almost 10 years. Yeah, that's the version I have. So you do have semantic search in the end there. Yeah, awesome. Yeah.
But yeah, Joan, it's interesting to introduce yourself to our audience. What's your background? How you got here? What are you up to? Oh, well, I guess that's a long story. I've had a very circuitous path. I started out in aerospace engineering because I like the math.
And as I got into the field, I found that that's a thing that I really liked once the math and was the software. You could do anything with those. And so while everyone was geeking out about satellites and stuff, I thought that was really cool.
But I realized that there's a big, big world out there that you could address the whole thing with software and math. So I breached out and got that book in your hand. My next big adventure was into search. I joined a concerted consultancy in Charlottesville, Virginia, worked with Doug Turnbull.
I did had amazing adventures, hop on planes. And I talked to Zappos, shoe sales and worked with a patent office. And then I got the opportunity to write that book with Doug. So that pushed me all really, really far.
I got the opportunity to start working for some really interesting companies or for Eventbrite and built out their search and recommendation twice. And then I got a chance to parly that into GitHub. So I went to GitHub and built out their last search-based code search infrastructure.
The old search infrastructure had smoke coming out of it. So we came in, rebuilt infrastructure from ground up. And after a while, I was search was fun. But I was always trying to get a little bit back towards math, towards data science tips.
And in about 2021, I got my chance to make the leak to data science. Join data science at GitHub. And from there, it ended up getting the opportunity, just right place, right time to join Copilot. Because that was kind of, you know, ML machine learning type stuff.
And I was in the data science group to that point. And I was, I came on to Copilot after the research team had wrapped up. There was a research team, brilliant people from GitHub next. They said, while look at these large language models, they're going to do amazing things. I think it's time.
And they built this prototype. And then I came in on the team that was there when it was going into production. So how to get this shipped to everyone, how to start improving it, how to measure, you know, what was working and what wasn't not working.
And then from there, I went into chat, Copilot chat. I was working with some of those features inside the web app. And finally, I was like, well, you know, I've got a little bit of knowledge in my head now, time to write another book.
And I connected with one of the research scientists that was on the original team. Albert Ziegler, we wrote the book, Prompt Engineering for Elements. It's about building the Elements applications.
And with that, just published two weeks ago, officially published, I have started out on a new adventure. Yet again, I am running Arturus Labs. I'm an indie consultant.
And I'm focusing on everything, large language models, Prompt Engineering, how to build applications, you know, it's feasibility, evaluations, stuff like that. Kind of anything you want at this point. And it's a blast. Oh, well, fantastic journey. Yeah, thanks for sharing that.
It's very, you know, it says a lot there. You will believe it or not. But I actually advertised your recent books, the Prompt Engineering, to my students on the recent course that we caught up with my former colleagues on LLMs and Generative AI. So I took the chapter on the rag.
And I thought that rag is nothing else than Prompt Engineering, really. Well, yeah, it's interesting. I mean, that's a topic in and of itself. Are we going to open that kind of worms? Of course. Sure.
Yeah, rag is an interesting thing because everyone talks about rag as if it's own entity, that it's a special thing.
But if you like look at it, especially from my background, which has been searched and then large language models, you click look at rag and it is search and then the large language models.
And if you combine them both, then it's really hard to get a good understanding of what's working and what's not working. You just, you know, you throw up the basic chain application, connect the data source. And I guess you just pray that it works.
But really, what it breaks, if you break it down to its components, then you've got a search application and the Prompt Engineering large language application that it overlaps. But a lot of it's kind of downstream.
And if you can look at those two chunks separately, it becomes a lot easier to debug problems. Rather than saying, you know, user asks this question, I got a garbage answer.
You can say the user asks this question, the large language model interpreted it as this search, this search, return these results. And maybe that's the, maybe that's where the problem was. And you can start debugging that. And the search results got interpreted this way.
And maybe you're not presenting it right to the model.
 So always the name of the game with it's probably everything we're going to talk about today is, you know, figured out how to take this giant black box and break it down into components and figure out what is, you know, what's it made of and what possibly is going wrong and put sensors there and actually debugger.
Yeah, you're absolutely right. And in the, in the lecture, I actually longed code from someone, I forgot their name, but I'll make sure to link it. We've built a rag ground up without using any framework whatsoever. You didn't mention Langchain, that's one way of doing it for sure.
But we just really built, you know, naive, can and search and just use the model out of the box, sentence, bird.
And then I've noticed that because we did use dot product there, I've noticed that it would favor longer passages over shorter ones, right? For example, it would pull up an appendix of a AI powered book, AI powered search book.
And I was like, like, you could clearly see that it's missing the point. It's not able to pull up one short sentence where the answer lies. It just pulls something else remotely related. And that's exactly what you said, right? Like you need to start debugging what's going on there.
And you need to start fixing on figuring out maybe change the model, maybe change the chunking. But yeah, I agree. It felt a bit like black box, but less so when you implement it ground up, right? So you don't depend on any framework.
And when you implement it ground up, you find out that it's not all of that complicated. And once you've built every piece of it, like, you know, I mean, you've already seen the black box broken down to its sub pieces. It's not a black box anymore.
So yeah, that's typically since the whole industry now is sorting itself, trying to figure out what tools are useful and what tools are not going to be useful, I often advocate that people start as close to the metal as possible.
Because these models are actually pretty friendly, pretty fun to play with. Don't put layers on top of it that obfuscate, you know, what's actually happening. Yeah, absolutely. I'm really itching to ask you more about now, like your time at GitHub.
But before that, I also want to like a little bit take your, you know, take a look at your approach, how you view your career, right? So you look, you worked on search, but then you ended up in the hottest place in the way, applying all the lamps, right?
And you needed to convert in a way to an ML engineer.
Do you view it that way? And also if you do, how did you prepare yourself to become a machine learning researcher, actually not even an engineer, right? You are focusing on research aspects of things. So you needed to move the needle in the research space.
I don't know if I have a good answer for you. Like if anyone thinks my career has been successful, which in many ways I've done all right, it's been luckily like tripping and falling uphill. Every time I fall down, it's like in the uphill direction. And I don't, I'm the hand of Providence.
And so what do I do with any of these crazy jumps that I make to prepare? Pretty much, I just take the jump. I think I'm going to say how I'm going to prepare for the next jump. I take, I see the jump. And then I jump into it and like almost drown every single time by surviving.
So in this particular case, yeah, the move towards AI researcher, I mean, there's a lot in that, there's a lot of weight in that phrase that maybe I don't necessarily feel in my own career.
By beginning search for so long and by wanting to do data science for so long, I made myself, you know, over time, pretty aware of how things were, you know, just the typical approach to the model.
So I was never caught any of this in school, but you know, you read, you read the right books and you know, go through the right examples. Yeah, so I have gained, I wouldn't say just an absolute comfort with any of this even now.
But you know, familiarity of being around it for periods of this point. And then when I jumped into the large language modeling stuff, it's actually kind of interesting because it's a different type of AI expert than we've had before and maybe an easier entrance for a lot of people.
Much of my career, I have been an engineer and really I still, I predominantly think of myself as an engineering mindset. And so when you come into, you know, large language models, it's actually really approachable.
You don't have to immediately know everything about, you know, what choice of models to use and like, you know, how to train and have the whole outside and evaluate.
And you can just go to work and at first, at least, just experiment and I really encourage people to do this when they're building on, they're on an application. Rather than, you know, thinking about all the evaluations and stuff at front, you'll need, don't worry, you'll get to them.
But just get your hands, hands dirty, start using the, the APIs and build up some intuition and a weird way empathy for these large language models. Yeah, yeah, this is brilliantly said. I just recently listened to the episode of Lex Friedman with the ontropic team.
So the CEO and some of the researchers there. And one of them said, yeah, exactly. And one of them said that you, along the lines of what you just said about empathy towards the model that when you know where model succeeds and where it kind of fails, you learn how to prompt it. Right.
You know, like which risks you will encounter and you should be okay with those, but you don't tilt towards more risky areas, in the west to succeed in some specific thing. So I don't know, I like that.
But what is your take on LLM unpredictability compared to more, if you will, you know, traditional programming per se. Right. So for example, when you, when we used to, when you used to write code, and I don't know, C++ Java, what have you? It was very deterministic in many ways.
Maybe there have been some things non deterministic like runtime and so on, but still you felt like you, you are in control of many things, right. With LLM, it's different. For example, when you ask an LLM to summarize a document for you, and then you ask second time, the answer will be different.
It will be, you know, in subtle ways, it will be different.
And so that also creates, in my mind, some issues around, okay, if I have several users accessing the same document, should they compute the summary on the fly, or should they compute it once and store it and then show the same copy to all of them, right.
But that also means that if the original summary was not good enough for some reason and subsequent versions were better, I will never show those better versions. Right. So like, you start asking all these like multitude of questions, or am I asking the wrong questions? It's such a challenge.
And I don't, yeah, it's it's a period. Right. Like if you're used to doing something with Python, it's going to be the exact same answer every single time. With these models, it's just like, you know, a very finicky person that keeps changing their opinion.
And you ask them the same question twice, and they've forgotten what they just said. Because it's a new session, so they literally don't have them. You're fully just that they start over. I think we're going to see a shift in this is not going to change anytime soon.
Just it's almost as if you kind of plug a fake human into the circuit. It's like it's going to be independent. That's the nature of it. And that nature is not going to change anytime soon. So I think what you're going to see is a modification in the way we build code around these things.
I think the pain point is when you assume that it's going to be as predictable as a code that you're used to.
But once you get over it, you realize that, okay, well, if I just literally had a human in the loop, there's like an API to connect to a human, then I have to be build a user experience that is somehow tolerant to that. And so let's see.
A lot of times people are hoping the first phrase into interacting with these things. They say, here's a specification, build this code, and they expect the answer to just forward. Now, that can fail in one of two big ways. One way is that it's just too complex.
The model you can do chain of thought reasoning, 01 has it built in and it's magic. And it's going to get better. But with any sufficiently large request, complex request, since you're just appending one token at a time, it's just too easy to paint yourself into a corner.
So models will get better and they'll be less and less likely to paint themselves into a corner. But it'll always be the case with sufficient complexity.
The other issue that you run into and why we'll never ever get there is because when I describe something, the domain of possible implementations, possible completions that match that input is so much larger than whatever I have in my head right now.
And so if you have a company that's like, you know, we're going to have like, you say the specification or code and it will just always make the code. It's like, you don't realize into the codes written which you even wanted. You don't, and then you go back and change it.
You don't realize the codes written and written incorrectly, you know, that, oh, that it's doing what I said. That's not what I meant.
So what does this all mean? I think that future implementations have to do a lot to keep the user in the loop and make the experience so that the user doesn't feel like they're just shouting instructions at a thing and then hoping that it works.
But the user has to be interacting with this thing and, you know, converging towards a solution. So you see this in a couple of ways. One way is like with the assistant interface.
And cursor, forgive me, GitHub, per se, the cursor is just a really good example here where you feel like you're chatting with someone that is working with you to, to, on this code. It gets into something I hope we talk about a little bit later.
Art of facts, you know, they're, you're having this conversation here, but you're working on these artifacts. You're working on these things. And these assistants under, you understand what they're looking at.
Whenever they make a recommendation to change something, you understand how it's going to change your code. You are still in control as a human, say yes or no for all this stuff. And that's one way that they keep the users in the loop.
The other way that we keep users in the loop, and I promise I'll shut up soon, is there's a assistant type behavior and then there's like workflows where a human is, it's still in the loop. But there is a human at the beginning that designed a workflow as like a set of steps.
You can't just say look at this website and pull out all the phone numbers, all of the menu items, all of the, you know, the structure content. And always expected to work.
Sometimes it's better to say, let's take this big thing and have a human, a human in this loop is defining all the steps that it's going to take to implement this workflow.
And that way it's still, you can make something that is recoverable, you know, that there's airstates for some of these steps and you can get out of them, pass it back up to a real human.
But yeah, all along the way of saying these things are going to remain hard to predict, but the code that's built around them, I think, is going to become very tolerant of that and by pulling the users into the conversation constantly.
Yeah, so you basically, if I got your idea right, is that you put the user in the driver's seat, right? And the model or whatever LLM app is still, it's kind of like an assistant, as you said, or companion, whatever you want to call it, right?
But you, like, you still, I guess we are still at that point in time when we need to know exactly what we want, right? As users.
And I think we also need to know how to get it out of the model, right?
Because sometimes no matter what you know, it's not somehow achievable, maybe because you don't know how to prompt well or, you know, you just go into the loops, I frequently go there, when I, for example, chat to, I don't know, chat GPT or it could be any other tool.
When it just keeps going and returning to the point which didn't work already, because the alternative doesn't work now. And I'm like, okay, neither work. Like what you propose just doesn't work.
What should I do? But still, I feel like I became much more productive as a, I don't write code every day, you know, for my work anymore, but for leaving. But when I do, I feel like I saved, I don't know, three, five days of my time by using these tools.
But there is still this kind of unpredictable component to it, you know, I'll give you one example, very specific one. So I was building like like simple Python code, which would draw a diagram. And on the x-axis, it would need to put, you know, these values like 1, 1.5, 2, 2.5 and so on.
And so the model made a mistake by rounding all these values to an integer. And so when x-axis, all of a sudden, I saw the same values, right? And the model doesn't have the reasoning component to realize that it made a mistake.
Or at least call it out and say, do you want it this way? Or should I do it another way? I had to correct it because I knew that I needed to cast it to float. But if I didn't know programming, I wouldn't be able to do that, right? I would be stuck right there.
And so that's the level lake of sophistication we are in still, right? If we're talking about code completion, but I wonder what you feel about this? What do you think about code complete?
You did call out cursor as the tool you use the probably more often now, but you did work on that in GitHub, Copilot team.
And what was your sense of its quality and like challenges around it? And in general, how did you approach the task that research challenge? I can speak a little bit of that. There's two ways in which I will be unsatisfactory here. One, I can't get into all the details probably.
And another way is I've been gone since May. So I'm sure that that makes an amazing change since then. But this Copilot completions was one of the first successful applications of large language models.
And outside of the pure model, chat to BT, a large language model as a large language model service. Like this is, this was just the, I guess it was the first. So the implementation was actually fairly simplistic. Basically, they, we weren't using chat models at the time. Those didn't exist.
We were only using completion models. Completion models, basically, I mean, your audience probably knows this, but given the top part of a document, then all the model does. And it's useful to think of the model this way. It simplifies things. All the model does is it picks the next token.
What is the most likely token based on all these words before it? What's the next token? And then you append that one and you did it again and again.
And so the big aha moment that happened probably in 2019, as well before my time on Copilot was, look, I can take this top half the code down to the function. And the answer, you know, the completion that it makes is surprisingly good.
So like maybe it's time to just wrap or wrap up for application around it. And then after that, everybody's learning these lessons at this point. But it's all about the context that you put around it and how you present it so that the model can make sense of it.
At the time that I started with Copilot, we were still using the completion models. And it was, the context itself was 2048 tokens, I think. So just tiny, tiny, tiny window.
And so a huge focus at the time was how to take all the things that we thought might be useful and squeeze it down into this tiny space, just, you know, actually make sure you've nailed it.
Because not only do you have to fit the prompt into this 2048 tokens, but whatever the completions are, that's, you know, that they're sharing the same windows. You can move that line up and down, but it's always in 2048. So there wasn't, there wasn't. The ingredients were pretty simple.
The file that you're looking at is obviously the most important thing. If the file is long, which I'll often I'll log in to that 48, then the text right above the cursor is an important thing.
There are some initial work with like the, they're still called fill in the middle models, which they don't need this anymore because all the models are so free. You don't need a specialized model for this.
But you could, you know, you could say the prefix and the suffix, and it would do a good job about filling in the middle. So the suffix was also an important part of the context.
Where do you stop this thing? And then as the model, crew is a context-based crew a little bit, we can start sticking in extra things. And so, you know, you start with little bitty things.
These models were not trained on, these models were trained on code, but they didn't necessarily have the context around the code. So the first easy thing to stick in is you could do a shabang at the top, protecting a comment that says, here's the path for this, this file.
And that gives the model context about where this lives in the context of everything else. A big breakthrough that Albert Dealer, Mike Coother, pioneered was the neighboring tab stuff. And I think this is all common sense these days.
But basically, when you, as a human, are using an IDE, you open up the file you're working on. But you also open up other files for reference. So, duh, why don't we, you know, do that ourselves. And the initial implementations of this that, you know, probably got not better at this point.
It was simple. It was like, look at the text right around the cursor. And then search these files for similar text. And in your timing, 2048 token space, you have any room for any of these snippets, then you can chunk other stuff into the context. You have to be careful how you present that.
You can't just, you know, have random scraps of text that are like, you know, partial function implementations. Because that will prime the model to implement partial functions. Like, it'll, you know, it'll just iterate the same gross pattern. It seems above.
So you do things that make it look more like code. You say, here is an interesting, you skip a code from this file in the comment so that it's still, you know, importantly, so it's still valid syntax at the end of it.
And voila, the rest of this history, we came out with a really impactful product that no one had seen anything like it before. And it's certainly changed the way I code. I'm much quicker and probably dumber at the same time. Yeah, it's been an interesting experience.
Oh, maybe more smart because you get to do more things, right? Like you can, I guess you can, you can get hired, like you can achieve, you know, larger heights and then, like experiment way, you need to experiment, right? And not where it feels maybe more mundane.
As long as the code works and like, I don't know, there are no security holes in it and stuff like that, which would need to be checked separately, I guess. Anyway, that's very interesting.
But to close up the loop there, like I'm just trying to understand, you said you focused on keyword search, right? So you, you owned the elastic search sort of pipeline.
Can you, if you're comfortable disclosing that, like, would that index the visible code in the ID somehow so that you can, or what was the role of that in the whole chain, hope, pipeline? You're asking a lot of questions that don't quite seek well on my actual experience.
Let me see, if I can take your question and you take it just a little bit. When I came to GitHub, I worked on code search, which was keyword, like, school search for the entire code corpus. And that was really cool work. But that has since moved to that, they've rebuilt the whole system yet again.
And it's a really amazing engine, the proprietary engine that's effectively grip at fantastically massive scale.
But that said, that code engine, the one that I built in, even the one that came after it, are not the things that are most beneficial for some of the applications that KhoPy that has in the editor. And they do different things for that.
They're, for example, if you're on the web app side, there are things, now I need even in the ID, I'm remembering stuff from six months ago, they do just in time like vector embedding vector storage and stuff.
Vectors are a lot better for certain types of code search where you're finding code that is about something. Whereas, lexical search is a lot better when you're finding code that matches this exact string.
And I think everyone in code outside of code, everyone everywhere is still kind of wrestling with this. There's no one data structure that does all that stuff ideally. And I think we were wrestling with that inside KhoPylet as well.
Yeah, but I guess, yeah, I understood your point and I probably missed that in your explanation that you worked on code search and not on the generation. That's why in code search, you did use the elastic search index.
 But like what I was imagining and I'm completely clueless in this topic, is that by the virtue of LLM being trained on bunch of code, let's say open source code that you can train on license wise, if the user is asking something that reminds the code that had written before, wouldn't it make sense to try to find that code and kind of somehow you know, rag on it with LLM or is it completely different than how you did it?
The like at this point, we've moved to much, it's you know, as of May my left, they've moved to much larger models.
And then the models themselves have read not only all the code and GitHub, but also it's read the internet five times or something. So they read all the blog posts about code. It's amazing, right? It's what times you live in.
 So whenever you're typing something and it kind of smells like something it's a thing before, it doesn't, it doesn't necessarily need rag to go get you know, common motifs, common, you know, here's what you're doing, here's what I think you're doing a code right now and it can piece code together from all the code it's ever learned from and extract late outside of it.
But if it is and you know, this is me talking about how maybe I would build a co-pilot. At some point I guess, you know, you need to see if it's if the user's typing code that is so similar to code in this code base that it's worth bringing it in.
And we kind of did that in a rudimentary way with the neighboring tabs. You've already got the tabs open. And that ended up being super useful.
I think there's probably a kind of a decreased efficacy, there's work for this, where if you're doing a rag search over the entire code base, probably the code that you're going to find is already code that's open in the tabs right beside them. So maybe it's useful to do that maybe it's not.
But I don't know. Yeah, interesting. I think code is like, as you said, it's the first successful LLM application. Probably some companies will say, no, no, no, Dr. Boog's was the first successful LLM application.
But I, but I, there were some, maybe it was the first successful neural search application. And then co-pilot was the first LLM application, successful LLM application. And there's plan nine.
Yeah, there was another company that was out there actually before us, but they just didn't have quite the same, they weren't only my Microsoft at the time, that probably helped a bit. Yeah, budget wise. I'm guessing. Yeah.
Yeah, but I still, I still feel like it feels like magic, right? Like, judgey PT also felt magic and scary in the beginning.
Like when I saw it for the first time and I saw it produce code, I thought that my job is done, even though I was not a programmer anymore by then, but I felt the existential, well, not crisis of fear that basically many of us, and especially junior developers, like probably not needed anymore.
But then as I was, you know, overcoming my fear and I was like, now let me try this thing. It's probably a toy. I found some, what I explained, you know, some edge cases, which just doesn't work. It goes in loops. And so I was like, okay, it seems like another tool under my belt.
So I better master it and not, you know, walk away from it.
But the code generation still feels like magic because you can explain, like you can use tap tab and like on a method signature complete, complete something or on the comment complete something, but you could also write natural language, right?
You could say, generate test cases for me or something like that, right? And then it will understand it and will read your code and will reason about it and produce the test cases.
I mean, that feels really magical. It's the time we're wandering into right now is going to feel like magic for a while until we've got to get used to the exponent, it's just going to keep going up and going up more, going up.
But you know, I've had those existential pains myself, but then I realized when I start using these new tools the way that they want me to use them, I have superpowers. I think what we're actually, you got to have the right mindset.
If your mindset is like, oh, my cobalt job is over, you might be right, your cobalt job is probably over. But if your mindset is like, oh, wow, I can do things I never could do before.
I, John Berryman, put together the HTML from my website and built a react app in this like, like I thought I'd have to have a PhD to do something like that. But it's amazing.
And what you're seeing is an emergence of a new group of people that are, they call us the AI natives, AI native development. And I've heard, you know, code composers rather than like just coders. And you have people that are technically savvy.
You can't, you have to have, you know, some ability to, to recode still at this point, to debuck some stuff like you were talking about. But they all go out at a screen, do this thing for me.
And they have, it just takes a little bit of experience to learn how to shout at the screen in the right way. You got to, you know, you've you still got to have the human ability to, you have to think about how this is structured, how to modularize stuff. There, there is a craft to it still.
But you, you can start building up pieces.
Even if you're not technically savvy, if you've been building it in chunks when one of these pieces messes up gloriously and you've got your floating point numbers that I don't work in out like your example, then at least you can say, I'm going to delete back to here.
I'm going to try a different route. See if I can just bump it out of this. And often you can. And people in every walk of life are are much more effective and efficient at creating.
And it's, you know, you don't get this, you don't always get to solve the nitpahee little, you know, if you really love debugging and writing tests, I'm sorry. I think that's your days might be numbered.
But if you love creating, that's I think we're approaching a new golden age and it's exponential. We're going to keep approaching new golden ages for a while. Yeah, I think in my career, if I can reflect a little bit, I, I love creating much more for sure.
But then back then, we didn't have a lamp, so didn't have compilates. We had to do pay a programming, right? And that was our command. Yeah.
And but the, the, the, that notion that you just said about creativity, I think that drove much more forward than us going into the rabbit down the rabbit holes, you know, of debugging that thing. However important that thing was, you know, of course, you need to debug and so on.
But it didn't feel, like you, you would just feel exhausted after that. You know, like, yeah, I fixed that bug. Finally, I squashed it.
Move on because you, you want to build stuff, right? You, and I think it was it, the extra who said, if debugging is the process of removing, finding and removing bugs, then programming must be the process of introducing bugs. And so that's right. Yeah. That's a vicious circle. Yeah.
You, you already touched on that topic a bit earlier about artifacts. I've read your blog posts, which will, will definitely link, link in and I, I got inspired by that.
I have to say, because oftentimes when I go to the set applications, you know, chat, GPT or perplexity, what have you, and you have a longer conversation there, it is hard to then sort of trace back and think, okay, I branched here and, okay, what was my thinking again?
What did I produce at that point? There is nothing to hold on to except scrolling back and forth.
And that's what you really put. And I want you to open, like, you basically proposed something new, I believe. I wonder if you are the creator of this or like, in any case, you carry this idea forward. Can you explain what do you mean by artifacts? I will carry the idea forward.
I think there is what we're seeing is some convergence around the notion that put into my blog post. For example, with anthropics, artifacts, so that they, they splash something that I think is getting at what I'm talking about.
But if you dig a little at the end, it's not quite what I'm talking about. Whenever you engaged in a conversation with an assistant, LM experience, they just want to chat. And so we've done good over time by giving them like tools.
So now it's rather than just like being your therapist, they can go inducing for you. So that's nice. But still, it's a linear flow. And whenever you're talking about something, it flows back into the backstroll.
Most of the time, when you are getting work done, you're getting work done on something. And artifact, there is a staple, I really wanted to call it a staple object of discourse because it isn't object. It's staple because it may change. And it's it's the object of the discourse.
But artifacts is not just easy to say. But this is what we deal with. Whenever we're paraprogramming on something, it's me and you looking at this piece of code, and you make a recommendation about this. And I say, that's good. We go back and forth.
And anything that you can imagine can be addressed like that. The situation becomes a particular point yet, when every you're dealing with multiple artifacts. So if you're saying, I really like this thing over here. And I wonder how it would fit in with this thing over here.
You're having, as a human, you're having to refer to more than one thing that exists outside of this linear conversation. And you're talking about how they relate to one another. And so the blog post, which I hope you guys all read, arterislabs.
com, we'll do this again in a second, right? It gets into what I think of as an artifact. It talks about how to build a prompt so that you have space for this linear conversation.
But you also draw the models attention to a chunk at the top, usually, you might put it all through, you might put it at the bottom to have an experiment with it. But a static chunk, which is like, here is all the things on the table that people can refer to.
Each object, each artifact, has importantly an ID to be referred to. And I've noticed that these models do really well with arbitrary hexadecimal IDs. So I'll just give them a random ID.
But they're really good at referring to those and not like, you know, they don't seem to hallucinate these IDs, which surprised me.
And so if you have a prompt with these artifacts at the top, and you have a system message that explains to the model how to interact with these things, then my experience is that they obey the instructions really well.
They talk humans are used to using pronouns and names and nicknames and, you know, other pointers that refer to the real thing.
And these models having read all the human text that they could get their hands on, the internet five times, they also understand what you mean about using using pronouns and stuff. So you can say, you know, dear model, there's this thing called artifact. They have these IDs.
When you refer to them, then use these, use anchors like in HML because they've seen a lot of those. And in the href tag, refer to it. And here's an example. And they just, I haven't done any like formal like, you know, reinforced testing, but in my experience with, they just haven't gone wrong.
They are comfortable referring to these things. And it provides a really slick experience, I think, for the user. The user at the end of this conversation is looking at a conversation that they don't have to scroll back up to. They're looking at artifacts on the right.
And they can, they can grab the ones they need. The artifacts themselves, you know, the application developer, you're in charge of how you want to present these things. If it's its text, you can just make it text.
But if it's like a home listing, you know, in the background, it can really be represented by, you know, JSON. But you present the user, you know, picture the home and the, you know, scrollable tab and maybe a scheduling button.
You can do all these rich things with artifacts that you can't do if you're just having a chit chat conversation and it's all just scrolling back into the back. So I think it's a cool enough idea.
I think there's some indications that it's coming into existence with, you know, Anthropocardic factor, GPT, OpenAI's Canvas. Persure is actually implicitly doing a really good job with somehow they're doing this. So it'll come into reality, I think, at some point. It just gives you an idea. Yeah.
It feels like it structures the interaction with the element.
It doesn't feel like you lost your time in a way that you, like, it's like you need to summarize it for your conversation, right? To go back and like tell you what was important, right? But how does it all know what is important? You know, but you already forgot.
And so if you have this artifacts, you can refer to them. But it's interesting that I think these artifacts can you use them? And by the way, I don't know, if you can demo something quickly, I saw a demo on your website. All right.
So this is how do you go to my website? Oh, and you know, check this out. This website was me and like chat GPT and cursor just kind of hanging out, teaching me some HTML. But yeah, you go to my blog. Wait a second. Wait a second. You've built this site with an LLM. Correct? Yeah.
That's what you said. Well, it was me and a large language ball. It wouldn't be just saying build a website. Of course. It's going to, it's the, it's what's going to happen in our future. It was everything is going to be a conversation working on this with a large language ball.
It's a beautiful website. I have to say, yeah, amazing. And the logo. Even the sniffy little logo was generated. AI. Oh, amazing. Okay. This is ridiculous. I'm going to take up just a little bit of your time. It's okay. Oh, it's fine. This logo right here. Check out how many cool things out.
There's, there's a bunch of little bits in here. And then I'll make give you a quiz so you can find the last thing hiding in this. Arcturus is a star in the Northern hemisphere. It's a navigational star. It's a brightest star. And it means guardian of the bear.
And so with my cubo logo here, you've got the a you got the bear. The a is kind of serves. It's a little looks like guardian. The bears represent of the big hairy problem. That's powerful. And but I'm going to, I'm going to help you out. The stars are all for for pointed. It's navigational.
There's one more little uh, uh, Easter egg in this that I didn't notice until I finished building it. I didn't design it. It just emerged. And if, yeah, I'll start doing it. If you're a good computer scientist, especially, oh yeah, then yeah, yeah, a star search, a star search. You got it.
You got it. You got it. I didn't even think about it. I just thought this needs kind of a star over here. And I looked at it and it's a star, which is, you know, optimal, near optimal navigation of the difficult domain ahead. LMS is a good at creating Easter eggs then. Yeah, very terrible jazz.
Yeah. So anyway, sorry, sorry for the, also the stars that was, I mean, these stars are amazing as well. You can just stare at them, right? And Marvel, they move, they look a bit like snowflakes sometimes as well. Yep, they do. All right, so thank you for the digression.
We're looking through my blog and we're looking through, uh, cut the chit chat with artifacts. One thing I'm trying to do recently with my blog, and I hope you guys will, you know, there's plenty of place where you can, uh, like, subscribe for this. I'm trying to put in plenty of examples.
And here's the kind of built-in example of it working. Let's see. You know what, this, we might very well edit this out, but I'm going to go down to the now you try a bit right here. Oh, if this is, uh, in a naive approach, uh, let's say that I'm building like a real estate, uh, helper assistant.
I help real estate agents. And the real estate agent says, I want to put together an email for client about, and I'm listed on Oak Street. Can you hold a listing? And so the thing has some tools built in. Uh, it's got a get listing tool. And so you can see all the garbage that puts in there.
And it's got this listing, um, but like, I don't, I've got the listing. It says it's got the listing. Somehow all this garbage, there's a listing, but I don't know what the listing's really about, um, and so I could ask about it, but then it's, it's a filter.
I don't have the thing that came from the database. I have this weird filter in front of it. Uh, can you pull an email template and draft a new email in another tool that it has? I guess it's going to take its sweet time to do it. Oh, of course. Hmm. Hmm. Okay.
Um, so it drafts, it drafts an email, but oh, look, I've forgotten this, the, the buyer's name. So this is one version of the email that is relevant to this thing right here. Uh, but, you know, I've forgotten to tell you his name is Tim Cersei and my company's name is Artie Tristral Estate.
Uh, it goes back to this and so it fills it in and then I'm left at the end of the conversation, you know, copy and paste in this out.
If this is what I want, I'm going to paste this in the user's email and be really embarrassed when it's got this little string at the top because I've copied that out. And if I wanted to do anything else like modify the template or do anything, it's, it's, it's just, it's not there for me.
All right. So let's, let's do a similar experience with, with this. I want to, uh, again, pull out that listing per, for Oak Street. Oh, I have an interesting. All right.
So in this time, I'm still showing that it, it knows how to use tools, but every time it tries to spit out this like JSON stuff, it's actually getting substituted in with an HRF that points to it. And what is it point to where you click on it and it automatically loads, uh, this scar right here.
Now, um, I didn't take time to make a real pretty interface, but you can, imagine this is JSON. You can make this look like anything you want to. You can make it link out to the database and do all sorts of things. All right. I'm going to put together that email template again. Yeah.
I guess especially when you build a dedicated LAM application, right? You know what type of, what types of objects you're going to be interacting with and you can build the, you know, I can do UI around those, right? But yeah, a very flexible, manable interface.
The interface is whatever the user needs it to be potentially. Yeah. All right. So it's, uh, it's, uh, it's, uh, got this customized email draft. Now, uh, you know, I was looking here, there's no email draft here, but there is here on, on the side of the screen.
And you can see unfortunately, I forgot, uh, to stick in the user's names. So, uh, let's see. Here's the template that it used. We didn't see that in the last example. You can see how it wants to put together stuff. You can see how it actually put together stuff.
And whenever I said I forgot his name, it said, Oh, okay, I've updated that artifact for you. So you don't have like multiple versions scaling up. You just got this. And you could do even interesting things like I could say, uh, you know, this is much better if I say gone bare, you man right here.
And that is now part of the artifact that the assistant sees. Uh, it's, it's in that artifact section at the top of the prompt. You can have it say, please change my email prompt forever to say something out of like this. And you can work on this and say that back to the day.
It just, oh, it opens up a lot of possibilities for a user experience that is easier. Because when we get work done, we get work on things, not just check. Yeah.
Your reason, your reason around artifacts and you work with them like as if they were physical objects almost, right? You can take away this thing with you and go proceed with your task. Yep. You refer to them. You modify them. We use them to do things. And you could, I'm guessing.
I'm really guessing. I'm new to this topic. You could maybe even condition the model on these things, right? You could say given this artifact, I want to do something else with it, like rewrite some parts. You know, would that work? I mean, this kind of sky is the limit.
Uh, it's, it's kind of been a fun thing to think about. But you could have typed artifacts. And then when you have a certain type of artifact, you could introduce the tools. Uh, so like, you know, if we need to modify this artifact artifact, we can, we can know how to deal with it.
You can have, it's kind of what I did with my next post, the roaming rag. You can have artifacts that are like accordions. They're, they're bigger than fit in the prompt.
But you can say, you know, here's summarized outline everything in every piece of that summary, uh, the model effectively can click on it and expand it. And it's just another ID and, you know, a tool expand the section. So it can read docs that are bigger than fits in its context.
There's just a lot of neat things that I think you can do with artifacts at the starting point. It's very interesting. Don't you think that just one thought across my mind is that when we transitioned from static web to like web 2.
0, I guess, so what is what was it called when you can actually modify things on the web, right? You could send a comment, you could, you could do stuff. Uh, now it feels like we've transitioned into the new phase when we do the same to the ideas.
We like exchange ideas and we can like modify them, you know, prior on them, prompt with them, uh, take away a store. So it becomes more on the concept level. I think everything's going to get really weird, uh, going forward. I think we've been used to going to the internet and going to web pages.
And even if we could interact a little bit, it's nothing like you're about to see. I wonder if a lot of the internet experiences, you know, they're worried about all the text going away, uh, because like we were, we'd run out, run out of the text, the internet, training these giant giant models.
Maybe the future of the internet is going to be replaced by just conversations. The, you're going to go to a place that is a sensible, you know, starting point, but the whole website is going to become whatever reality you need it to be at the time.
And I have no idea how we harvest the text of that train of future models. It might be crazy, but I think I think we're getting ready for a future we cannot possibly predict. Yeah, and I think spam will be replaced by slope, right? I don't know if you heard of this, YouTube.
No, slow, slow, slow is, uh, SLOP. So it's basically an unverified output of an LLAM model. So something that got produced back to your question, you don't, you have no idea if it's true or not, you go and paste it somewhere in the web and then LLAM goes and scraps it and learns from it.
So you spam the model. And so there is a call out. If this feedback effect. Yeah, exactly. And there is a call out that, hey, let's not spam or let's not post slope on the web because that will bite us because we are moving so far ahead in the LLAM. And who is obeying that recommendation? Exactly.
Probably not the companies that need content produced. Yeah. Yeah. The moment you say, don't do something, there will be a bunch of people saying, oh, let's try. That sounds like fine. Oh, that's a good idea. And then we need to invent a solution for that. Hey, Jonathan, it was really exciting.
And I've known it like a ton by talking to you. I feel like we can record probably like like three months style episode, you know, four or five hours before we get exhausted. But I also wanted to give you a chance to, you know, go on stage and sort of and talk about your book way.
Like, why do you think everyone needs to read it? I want to read it. If I get a chance to get my hands on it, hopefully soon. Everyone needs to read it because every time I make a sale, I get one cup of coffee. So that's why everyone needs to read it. Of course. Yeah, that's a good reason.
But then also, yeah, go ahead. No, I wanted also you to give you a chance to talk about your company.
Because I know that feeling of starting something new on your own, you call yourself an indie consultant, right? At the same time, you have so much with you and your luggage, right? Like you, the knowledge of the experience. And so why not share it in a different way through your company.
But I wanted to learn a bit more. What is your vision for the company? What do you think you will offer like in midterm? Where do you create the value for the customers? And maybe there will be some customers listening in this podcast, hopefully. Sure.
Well, okay, let's go through both of those then. I hope I hope everyone reads the book. I hope they enjoy it. I hope they learn from it. Working with large language models is a very different beast from what you're used to.
I think, you know, three years from now, everyone will be a large language model application developer because they're becoming so prevalent everywhere. So start early. Get your hands dirty, interact with these things.
And my book helps kind of take, you know, give you the training wells at first to understand here are a bunch of the problems that you run into. Here's how here's how model works. That's there's actually a lot of good intuition and just understanding the tool that you're interacting with.
Here's how to organize a prompt. And that's not always easy. You got to figure out what's all the stuff you might use. And you can't use all of it because it doesn't all fit or because you don't want to wait for the latency.
You know, it tells you how to, you know, fit that into a prompt, present it to the model in a way that kind of empathetically, the model is going to understand the model is not psychic. You need to talk to the model as if you're talking to, you know, someone that you're working with.
 And then towards the end of the book, it gets outside of a single prompt and it talks about, you know, like this tool magic word we've got right now, agency and how to build a assistant behavior with tools and how to, you know, build a more sophisticated thinking steps with it in review of, you know, what's happened.
And it talks about workflows, which is another type of agency really about how to, you know, take an input, bunch of data, pick it apart, do the right steps to get a job done with hopefully not going off track too much.
We talk a little bit about evaluation and we wrap it up by saying holy cow, look at the future we're going into. This is going to be amazing. So I hope you get a chance to read the book and I hope you enjoy it. I hope it's as enjoyable to you as it was painful to me to write.
And then yes, I am out of my own now. I'm an indie consultant at Arturus Labs. I'm specializing in all things just like the book, prompt engineering, large language model application development. I think we're going into a very different world as far as like how you build things.
You've got to build it like we had earlier in this conversation. You've got to build these components to deal with. You've got to build it web apps to deal with these components that are very undependable. I do make them as dependable as possible.
How do you make the user experience where they trust what's happening? And that's tricky. So I offer a whole range of things from just education, going in and training companies. I like going and working with them to think through what product they're working on right now with their next big goal.
I can say this is a great idea. You're on the right track. This is not quite feasible, but we can fix it. That's the product type stuff I like thinking through. And then as we get to a longer engagement, I just love working with these companies, especially like startups.
Just sit down, pair with them, do transfer of knowledge, type stuff. It's just really neat to see what people are up to. A lot of creative ideas right now. And then finally, yeah, please make sure you check out my website, www.artrisslabs.com.
I'm going to throw together a lot more blog posts like the one we didn't know today. I'm trying right now to make sure every blog post has something juicy, a piece of code that actually works and you can experience the thing that was running to my mind at the time. So try it out.
I'm really engaging on Twitter. Tell me what you think. And yeah, I'd like to get to to know you guys too. Yeah, amazing, amazing. And I wish you all the best with your new adventure, your new venture. And yeah, we will link everything. We will link the book.
We will link your site and blogs for sure. Thanks so much for spending time with me and educating me and keeping up with Mike sometimes, you know, and obvious questions. It was really, really a pleasure to talk to you.
And I really, really hope that we can record sometime soon because you seem to be cooking a lot of ideas. And you take from what I gather, you take really practical view of things. And you've been like, and you are an engineer and researcher. And so that's very dear to my heart to see.
And I can't wait to see what you come up with next. Me too. Well, thanks so much for having me on. It's been great talking to you. So yeah, let's do this again sometime. Yeah, thanks, John. Have a good day.